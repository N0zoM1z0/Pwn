学习参考：[cve-2021-3156-sudo堆溢出简单分析 - hac425 - 博客园 (cnblogs.com)](https://www.cnblogs.com/hac425/p/14336484.html)



因为漏洞利用起来感觉比较复杂，这里就静态分析下产生漏洞的代码。

漏洞版本源码：

```	
https://github.com/sudo-project/sudo/archive/SUDO_1_9_5p1.tar.gz
```



漏洞点在：

```
/plugins/sudoers
```

下的`set_cmnd`函数。

```c
if (NewArgc > 1) {
	    char *to, *from, **av;
	    size_t size, n;

	    /* Alloc and build up user_args. */
	    for (size = 0, av = NewArgv + 1; *av; av++)
		size += strlen(*av) + 1;
	    if (size == 0 || (user_args = malloc(size)) == NULL) {
		sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
		debug_return_int(NOT_FOUND_ERROR);
	    }
	    if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
		/*
		 * When running a command via a shell, the sudo front-end
		 * escapes potential meta chars.  We unescape non-spaces
		 * for sudoers matching and logging purposes.
		 */
		for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
		    while (*from) {
			if (from[0] == '\\' && !isspace((unsigned char)from[1]))
			    from++;
			*to++ = *from++;
		    }
		    *to++ = ' ';
		}
		*--to = '\0';
	    }
```



先给一个PoC：

```bash
sudoedit -s '\' 112233445566
```



进入这个函数时的NewArgv结构：

```c
NewArgv[0]: sudoedit
NewArgv[1]: \
NewArgv[2]: 112233445566
```

先是计算[1]和[2]的长度，2+13=15，malloc(15)

注意这段代码逻辑：

```c
if (from[0] == '\\' && !isspace((unsigned char)from[1]))
			    from++;
```

我们在复制NewArgv[1]的时候，from[0]='`\`'，且from[1] = `b'\x00'`，所以不是space，会使from++

那么此时from就指向NewArgv[2]，所以处理NewArgv[1]的时候其实是复制的NewArgv[2]！！！

而后面处理NewArgv[2]的时候也是复制的NewArgv[2]，那么就复制了13*2=26大小的数据到15大小的堆。（当然得考虑对齐）

所以我们可以在NewArgv[2]的位置构造堆溢出。



具体利用Exp以目前的水平是分析不来的，因为实战的堆比CTF的复杂多了。。。

但这个漏洞点确实有意思。（而且肯定是fuzz出来的）